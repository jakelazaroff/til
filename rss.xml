<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
<channel>
<title>jakelazaroff TIL</title>
<description>A collection of useful things I've learned.</description>
<link>https://github.com/jakelazaroff/til</link>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/rust/link-against-a-cpp-file.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/rust/link-against-a-cpp-file.md</link>
<title>TIL (rust): Link against a C++ file</title>
<pubDate>Tue, 26 Dec 2023 06:28:28 GMT</pubDate>
<content:encoded>&lt;p&gt;While Rust natively supports linking against C, it needs an extra binding layer in order to link against C++. Although a library called &lt;a href=&quot;https://rust-lang.github.io/rust-bindgen/introduction.html&quot;&gt;bindgen&lt;/a&gt; can generate those bindings automatically, I wanted to see how to do it myself.&lt;/p&gt;
&lt;p&gt;Rust has extensive documentation on writing a &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html&quot;&gt;foreign function interace&lt;/a&gt;; here&amp;#39;s a minimal example of how to do it.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say we want to call this function in &lt;code&gt;lib/inc.cpp&lt;/code&gt; from Rust:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;quot;inc.h&amp;quot;

int twice(int x) { return x * 2; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the header file &lt;code&gt;lib/inc.h&lt;/code&gt;, &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/1041880&quot;&gt;makes the function name linkable from C code&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;extern &amp;quot;C&amp;quot; {
int twice(int x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can compile that function into a shared library &lt;code&gt;lib/libinc.so&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;g++ -shared lib/inc.cpp -o lib/libinc.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that in this case, we&amp;#39;re defining a C-linkable interface in the C++ file itself rather than adding an extra layer between C++ and Rust. If we couldn&amp;#39;t change the C++ source code, we could add another file in C or C++ that calls the C++ library, and then expose the C-linkable interface from &lt;em&gt;that&lt;/em&gt; file.)&lt;/p&gt;
&lt;p&gt;In Rust, we can define a list of foreign functions within an &lt;code&gt;extern&lt;/code&gt; block, and then call into them from Rust code. Rust treats all foreign functions as unsafe, so we need to call it from within an &lt;code&gt;unsafe&lt;/code&gt; block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;extern &amp;quot;C&amp;quot; {
    fn twice(x: i32) -&amp;gt; i32;
}

fn main() {
    unsafe {
        println!(&amp;quot;{}&amp;quot;, twice(2));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trying to build or run this will result in a linker error about undefined symbols. We need to tell Rust how to find the library, which we can do by placing a &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib&quot;&gt;&lt;code&gt;build.rs&lt;/code&gt; file&lt;/a&gt; in the package root. TL;DR from the docs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build scripts communicate with Cargo by printing to stdout. Cargo will interpret each line that starts with cargo: as an instruction that will influence compilation of the package. All other lines are ignored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here&amp;#39;s our &lt;code&gt;build.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;fn main() {
    println!(&amp;quot;cargo:rustc-link-search=lib&amp;quot;);
    println!(&amp;quot;cargo:rustc-link-lib=inc&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cargo:rustc-link-search=lib&lt;/code&gt; tells Cargo to look in the directory &lt;code&gt;lib&lt;/code&gt; for C libraries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo:rustc-link-lib=inc&lt;/code&gt; tells Cargo to link against &lt;code&gt;libinc&lt;/code&gt; (the &lt;code&gt;lib&lt;/code&gt; prefix is implied)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boom! Running &lt;code&gt;cargo run&lt;/code&gt; should now correctly print &lt;code&gt;4&lt;/code&gt; to the console.&lt;/p&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/c/prevent-clangformat-from-breaking-before-curly-braces.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/c/prevent-clangformat-from-breaking-before-curly-braces.md</link>
<title>TIL (c): Prevent ClangFormat from breaking before curly braces</title>
<pubDate>Fri, 22 Dec 2023 22:30:45 GMT</pubDate>
<content:encoded>&lt;p&gt;For some unfathomable reason, C and C++ developers sometimes put line breaks before curly braces:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main()
{
  for (int i = 0; i &amp;lt; 10; i++)
  {
    printf(&amp;quot;%d\n&amp;quot;, i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s also the default formatting style in the code formatter &lt;a href=&quot;https://clang.llvm.org/docs/ClangFormat.html&quot;&gt;ClangFormat&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, it&amp;#39;s configurable by setting the &lt;a href=&quot;https://clang.llvm.org/docs/ClangFormatStyleOptions.html#breakbeforebraces&quot;&gt;&lt;code&gt;BreakBeforeBraces&lt;/code&gt; option&lt;/a&gt; to &lt;code&gt;Attach&lt;/code&gt; in your &lt;code&gt;.clang-format&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BreakBeforeBraces: Attach
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much more readable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main() {
  for (int i = 0; i &amp;lt; 10; i++) {
    printf(&amp;quot;%d\n&amp;quot;, i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/htmx/load-modal-content-when-shoelace-dialog-opens.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/htmx/load-modal-content-when-shoelace-dialog-opens.md</link>
<title>TIL (htmx): Load modal content when a Shoelace dialog opens</title>
<pubDate>Fri, 08 Dec 2023 05:45:20 GMT</pubDate>
<content:encoded>&lt;p&gt;This is pretty idiosyncratic to &lt;a href=&quot;https://htmx.org&quot;&gt;HTMX&lt;/a&gt; and &lt;a href=&quot;https://shoelace.style&quot;&gt;Shoelace&lt;/a&gt;, but it&amp;#39;s a neat pattern so I&amp;#39;m documenting it here.&lt;/p&gt;
&lt;p&gt;HTMX lets you make an HTTP request in response to an event and insert it elsewhere into the DOM. Shoelace&amp;#39;s &lt;a href=&quot;https://shoelace.style/components/dialog&quot;&gt;Dialog&lt;/a&gt; component fires an &lt;code&gt;sl-show&lt;/code&gt; event when the dialog opens. These can be combined to automatically load modal content when the modal opens:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;sl-dialog hx-get=&amp;quot;/modal/content/&amp;quot; hx-trigger=&amp;quot;sl-show&amp;quot;&amp;gt;&amp;lt;/sl-dialog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If parts of the modal don&amp;#39;t need to be loaded via HTTP — for example, the title — &lt;code&gt;hx-target&lt;/code&gt; can be used to replace only the modal content:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;sl-dialog hx-get=&amp;quot;/modal/content/&amp;quot; hx-trigger=&amp;quot;sl-show&amp;quot; hx-target=&amp;quot;find .content&amp;quot;&amp;gt;
  &amp;lt;span slot=&amp;quot;label&amp;quot;&amp;gt;My Modal&amp;lt;/span&amp;gt;
  &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
&amp;lt;/sl-dialog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/typescript/assert-that-a-variable-is-not-null-or-undefined.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/typescript/assert-that-a-variable-is-not-null-or-undefined.md</link>
<title>TIL (typescript): Assert that a variable is not &#x60;null&#x60; or &#x60;undefined&#x60;</title>
<pubDate>Wed, 06 Dec 2023 20:23:27 GMT</pubDate>
<content:encoded>&lt;p&gt;TypeScript uses &lt;code&gt;!&lt;/code&gt; as a &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot;&gt;non-null assertion operator&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;const foo = document.querySelector(&amp;quot;#foo&amp;quot;); // Element | null;
const bar = document.querySelector(&amp;quot;#bar&amp;quot;)!; // Element;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I avoid it because it&amp;#39;s the same as JavaScript&amp;#39;s unary not operator, which makes it difficult to grep. Instead, I generally prefer to assert types with &lt;code&gt;as TypeName&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;const foo = document.querySelector(&amp;quot;#foo&amp;quot;) as Element;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That has a couple drawbacks. Other than being more verbose, it&amp;#39;s possible to cast the type to something incorrect:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;const foo = document.querySelector(&amp;quot;svg&amp;quot;) as HTMLElement;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But! You can chain the &lt;code&gt;!&lt;/code&gt; non-null assertion operator as many times as you want:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;const foo = document.querySelector(&amp;quot;#foo&amp;quot;)!!!; // Element
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I prefer that to &lt;code&gt;as&lt;/code&gt; assertions. It&amp;#39;s greppable (since using three consecutive unary nots is unlikely), it&amp;#39;s less verbose, there&amp;#39;s no chance of accidentally changing the type and a bunch of repeated exclamation marks definitely calls out that something unusual is happening with that code.&lt;/p&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/tailwind/style-shadow-trees-from-the-light-dom.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/tailwind/style-shadow-trees-from-the-light-dom.md</link>
<title>TIL (tailwind): Style shadow trees from the light DOM</title>
<pubDate>Tue, 14 Nov 2023 22:29:00 GMT</pubDate>
<content:encoded>&lt;p&gt;I&amp;#39;ve been really enjoying the web component library &lt;a href=&quot;https://shoelace.style&quot;&gt;Shoelace&lt;/a&gt; as a replacement for framework-specific UI libraries like &lt;a href=&quot;https://www.radix-ui.com&quot;&gt;Radix&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shoelace uses the shadow DOM to encapsulate its markup from the light DOM (aka the rest of the page), which means that class selectors can&amp;#39;t reach it. This presents a problem for CSS utility frameworks like Tailwind, which use classes for everything.&lt;/p&gt;
&lt;p&gt;Web components can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/part&quot;&gt;&lt;code&gt;part&lt;/code&gt; attribute&lt;/a&gt; to let outside stylesheets select elements in shadow DOM. For example, here&amp;#39;s the shadow tree of &lt;a href=&quot;https://shoelace.style/components/switch&quot;&gt;Shoelace&amp;#39;s Switch component&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;label part=&amp;quot;base&amp;quot; class=&amp;quot; switch switch--medium &amp;quot;&amp;gt;
  &amp;lt;input class=&amp;quot;switch__input&amp;quot; type=&amp;quot;checkbox&amp;quot; role=&amp;quot;switch&amp;quot; title name aria-checked=&amp;quot;false&amp;quot; /&amp;gt;

  &amp;lt;span part=&amp;quot;control&amp;quot; class=&amp;quot;switch__control&amp;quot;&amp;gt;
    &amp;lt;span part=&amp;quot;thumb&amp;quot; class=&amp;quot;switch__thumb&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/span&amp;gt;

  &amp;lt;div part=&amp;quot;label&amp;quot; class=&amp;quot;switch__label&amp;quot;&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/label&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS in the light DOM can&amp;#39;t select these elements using classes like &lt;code&gt;switch__control&lt;/code&gt; — it needs to select these elements using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/::part&quot;&gt;&lt;code&gt;::part()&lt;/code&gt; pseudo-element&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;sl-switch::part(control) {
  background-color: red;
}

sl-switch::part(thumb) {
  background-color: white;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although Tailwind can&amp;#39;t target these parts out of the box, you can write a plugin to do it using &lt;a href=&quot;https://tailwindcss.com/docs/plugins#dynamic-variants&quot;&gt;dynamic variants&lt;/a&gt; (Tailwind classes that accept arbitrary values):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const plugin = require(&amp;quot;tailwindcss/plugin&amp;quot;);

module.exports = {
  plugins: [
    plugin(function ({ matchVariant }) {
      matchVariant(&amp;quot;part&amp;quot;, value =&amp;gt; &#x60;&amp;amp;::part(${value})&#x60;);
    })
  ]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This adds a &lt;code&gt;part&lt;/code&gt; modifier that you can use like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;sl-switch class=&amp;quot;part-[control]:bg-red-500 part-[thumb]:bg-white part-[thumb]:rounded&amp;quot;&amp;gt;
  label
&amp;lt;/sl-switch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/github/run-github-actions-locally.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/github/run-github-actions-locally.md</link>
<title>TIL (github): Run GitHub Actions locally</title>
<pubDate>Wed, 27 Sep 2023 04:21:36 GMT</pubDate>
<content:encoded>&lt;p&gt;A common pain point with GitHub Actions is that the feedback loop is so long: make a change, push, wait for it to run, find an error, try to debug, repeat. Which is why I was so happy to discover &lt;a href=&quot;https://github.com/nektos/act&quot;&gt;&lt;code&gt;act&lt;/code&gt;&lt;/a&gt;, a tool for running GitHub Actions locally! The only prerequisite is Docker, which &lt;code&gt;act&lt;/code&gt; uses to pull the appropriate images to run your actions.&lt;/p&gt;
&lt;p&gt;By default, &lt;code&gt;act&lt;/code&gt; will run the action for the &lt;code&gt;push&lt;/code&gt; event, although you can configure it to run specific events or jobs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# run the &#x60;push&#x60; event:
act

# run a specific event:
act pull_request

# run a specific job:
act -j test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If your action needs a GitHub token (for example, if you&amp;#39;re checking out your code with &lt;a href=&quot;https://github.com/actions/checkout&quot;&gt;&lt;code&gt;actions/checkout&lt;/code&gt;&lt;/a&gt;) you can supply it with the &lt;code&gt;-s&lt;/code&gt; flag (for &amp;quot;secrets&amp;quot;) and the &lt;code&gt;GITHUB_TOKEN&lt;/code&gt; environment variable. This is easiest if you have the &lt;a href=&quot;https://cli.github.com/&quot;&gt;GitHub CLI&lt;/a&gt; installed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;act -s GITHUB_TOKEN=&amp;quot;$(gh auth token)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the &lt;a href=&quot;https://github.com/nektos/act#github_token&quot;&gt;official docs&lt;/a&gt; note that supplying your token in this way can leak it to the shell history.&lt;/p&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/htmx/attach-attributes-to-dynamically-added-elements.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/htmx/attach-attributes-to-dynamically-added-elements.md</link>
<title>TIL (htmx): Attach attributes to dynamically added elements</title>
<pubDate>Mon, 25 Sep 2023 05:20:01 GMT</pubDate>
<content:encoded>&lt;p&gt;It&amp;#39;s barely mentioned within the HTMX documentation, but by default HTMX attributes only work on elements that were in the DOM when HTMX was loaded, or that HTMX itself added to the DOM. This means that if you add an element by some other means — say, AlpineJS — HTMX won&amp;#39;t know about any attributes on it or its descendants.&lt;/p&gt;
&lt;p&gt;In the below example with AlpineJS and HTMX, the toggle button can be clicked to show and hide the form — but the &lt;a href=&quot;https://htmx.org/attributes/hx-boost/&quot;&gt;&lt;code&gt;hx-boost&lt;/code&gt; attribute&lt;/a&gt; won&amp;#39;t be detected, which means that it will be a normal form submission:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div x-data=&amp;quot;{ show: false }&amp;quot;&amp;gt;
  &amp;lt;template x-if=&amp;quot;show&amp;quot;&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;/some/endpoint&amp;quot; hx-boost=&amp;quot;true&amp;quot;&amp;gt;
      &amp;lt;input name=&amp;quot;firstname&amp;quot; /&amp;gt;
      &amp;lt;input name=&amp;quot;lastname&amp;quot; /&amp;gt;
      &amp;lt;button&amp;gt;Submit&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/template&amp;gt;
  &amp;lt;button @click=&amp;quot;show = !show&amp;quot;&amp;gt;Toggle&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTMX provides a function &lt;a href=&quot;https://htmx.org/api/#process&quot;&gt;&lt;code&gt;htmx.process&lt;/code&gt;&lt;/a&gt; that checks a given element for HTMX attributes. Call it like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;htmx.process(document.body);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code snippet can be fixed with the &lt;a href=&quot;https://htmx.org/attributes/hx-boost/&quot;&gt;AlpineJS &lt;code&gt;x-effect&lt;/code&gt; directive&lt;/a&gt;, which runs an expression when the tag is added to the DOM:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div x-data=&amp;quot;{ show: false }&amp;quot;&amp;gt;
  &amp;lt;template x-if=&amp;quot;show&amp;quot;&amp;gt;
    &amp;lt;form x-effect=&amp;quot;htmx.process($el)&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;/some/endpoint&amp;quot; hx-boost=&amp;quot;true&amp;quot;&amp;gt;
      &amp;lt;input name=&amp;quot;firstname&amp;quot; /&amp;gt;
      &amp;lt;input name=&amp;quot;lastname&amp;quot; /&amp;gt;
      &amp;lt;button&amp;gt;Submit&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/template&amp;gt;
  &amp;lt;button @click=&amp;quot;show = !show&amp;quot;&amp;gt;Toggle&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/typescript/type-concrete-subclasses-of-an-abstract-class.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/typescript/type-concrete-subclasses-of-an-abstract-class.md</link>
<title>TIL (typescript): Type concrete subclasses of an abstract class</title>
<pubDate>Wed, 13 Sep 2023 19:01:29 GMT</pubDate>
<content:encoded>&lt;p&gt;Let&amp;#39;s say there&amp;#39;s an an inheritance hierarchy consisting of an abstract base class and two concrete subclasses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;abstract class Base {
  constructor(exampleParam: number) {}
  abstract foo(): void;
}

class A extends Base {
  foo() {
    console.log(&amp;quot;A&amp;quot;);
  }
}

class B extends Base {
  foo() {
    console.log(&amp;quot;B&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an inheritance hierarchy, it&amp;#39;s common to reference a group of subclasses by their base class (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;function doSomething(obj: Base) {
  base.foo();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One situation in which this gets thorny for abstract classes is where a subclass that won&amp;#39;t be known until runtime must be instantiated. In this case, referring to the base class directly will result in errors about how TypeScript cannot create an instance of an abstract class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;function instantiate(Class: typeof Base) {
  return new Class(10); // Cannot create an instance of an abstract class.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of using the abstract base class&amp;#39;s type directly, instead create an object type in which a constructor (a &lt;code&gt;new&lt;/code&gt; method) returns an instance of the abstract class. If the constructor takes any parameters, they can be extracted using the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/utility-types.html#constructorparameterstype&quot;&gt;&lt;code&gt;ConstructorParameters&lt;/code&gt;&lt;/a&gt; utility type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;function instantiate(Class: { new (...params: ConstructorParameters&amp;lt;typeof Base&amp;gt;): Base }) {
  return new Class(10);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/javascript/access-css-variables-from-javascript.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/javascript/access-css-variables-from-javascript.md</link>
<title>TIL (javascript): Access CSS variables from JavaScript</title>
<pubDate>Sat, 26 Aug 2023 17:33:14 GMT</pubDate>
<content:encoded>&lt;p&gt;In building &lt;a href=&quot;https://fxplayground.pages.dev/&quot;&gt;fxplayground&lt;/a&gt;, I wanted to use colors from the site&amp;#39;s theme in a canvas visualization. The theme colors were all stored in CSS custom properties (variables), but the visualization drawing code was all JavaScript. I needed a way to read the CSS color variables from within JavaScript code.&lt;/p&gt;
&lt;p&gt;Luckily, there&amp;#39;s a function called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle&quot;&gt;&lt;code&gt;getComputedStyle&lt;/code&gt;&lt;/a&gt; that can help with that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const color = getComputedStyle(document.documentElement).getPropertyValue(&amp;quot;--color-primary&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getComputedStyle&lt;/code&gt; takes a DOM node and returns a live &lt;code&gt;CSSStyleDeclaration&lt;/code&gt;, which contains all the styles applied to that element. Calling &lt;code&gt;getPropertyValue&lt;/code&gt; returns the value for a given property, which includes CSS variable declarations. So if there&amp;#39;s a variable defined on the &lt;code&gt;:root&lt;/code&gt; selector, you can get the value by calling &lt;code&gt;getPropertyValue(&amp;quot;--variable-name&amp;quot;)&lt;/code&gt;!&lt;/p&gt;
</content:encoded>
</item>
<item>
<guid>https://github.com/jakelazaroff/til/blob/main/javascript/load-a-user-created-javascript-file-in-the-browser.md</guid>
<link>https://github.com/jakelazaroff/til/blob/main/javascript/load-a-user-created-javascript-file-in-the-browser.md</link>
<title>TIL (javascript): Load a user-created JavaScript file in the browser</title>
<pubDate>Mon, 21 Aug 2023 18:55:09 GMT</pubDate>
<content:encoded>&lt;p&gt;I ran into this when building a &lt;a href=&quot;https://jakelazaroff.com/words/building-a-live-coding-audio-playground/&quot;&gt;live coding audio playground&lt;/a&gt;, and presumably it&amp;#39;s useful for other similar apps. The issue is that APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AudioWorklet&quot;&gt;&lt;code&gt;AudioWorklet&lt;/code&gt;&lt;/a&gt; expect to be given a separate JavaScript file to run as a worker or worklet, but for apps in which the user writes code themselves there&amp;#39;s no easy way to serve that file (without running a webserver).&lt;/p&gt;
&lt;p&gt;The trick is to use a combination of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; (which represents raw data, plus some file-specific things like a name) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL_static&quot;&gt;&lt;code&gt;URL.createObjectURL&lt;/code&gt;&lt;/a&gt;, which lets you create &amp;quot;stub&amp;quot; URLs for &lt;code&gt;File&lt;/code&gt; objects.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s how to use the trick create a Web Worker:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// source code goes here
const src = &amp;quot;&amp;quot;;

// create a fake JS file from the source code
const file = new File([src], &amp;quot;file.js&amp;quot;);

// create a URL for the fake JS file
const url = URL.createObjectURL(file.slice(0, file.size, &amp;quot;application/javascript&amp;quot;));

// add the fake JS file as a Web Worker
const worker = new Worker(url);

// revoke the URL so as to not leak memory
URL.revokeObjectURL(url);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The call to &lt;code&gt;file.slice&lt;/code&gt; is there to fix a Safari bug where it can&amp;#39;t infer the MIME type.&lt;/p&gt;
</content:encoded>
</item>
</channel>
</rss>